{"name": "test_case[case0]", "status": "broken", "statusDetails": {"message": "UnboundLocalError: local variable 'res' referenced before assignment", "trace": "self = <RequestHandler.RequestHandler object at 0x10e846490>\n\n    def send_request(self):\n        \"\"\" 发请求 \"\"\"\n        headers = {'Content-Type': 'application/json'}\n        try:\n            put_request = urllib.request.Request(\n                url=self.case['case_url'],\n                data=self.case['case_params'],\n                headers=headers,\n                method=self.case['case_method'])\n>           res = urllib.request.urlopen(put_request) #返回参数\n\nRequestHandler.py:44: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nurl = <urllib.request.Request object at 0x10e846710>, data = None, timeout = <object object at 0x10c7353e0>\n\n    def urlopen(url, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n                *, cafile=None, capath=None, cadefault=False, context=None):\n        '''Open the URL url, which can be either a string or a Request object.\n    \n        *data* must be an object specifying additional data to be sent to\n        the server, or None if no such data is needed.  See Request for\n        details.\n    \n        urllib.request module uses HTTP/1.1 and includes a \"Connection:close\"\n        header in its HTTP requests.\n    \n        The optional *timeout* parameter specifies a timeout in seconds for\n        blocking operations like the connection attempt (if not specified, the\n        global default timeout setting will be used). This only works for HTTP,\n        HTTPS and FTP connections.\n    \n        If *context* is specified, it must be a ssl.SSLContext instance describing\n        the various SSL options. See HTTPSConnection for more details.\n    \n        The optional *cafile* and *capath* parameters specify a set of trusted CA\n        certificates for HTTPS requests. cafile should point to a single file\n        containing a bundle of CA certificates, whereas capath should point to a\n        directory of hashed certificate files. More information can be found in\n        ssl.SSLContext.load_verify_locations().\n    \n        The *cadefault* parameter is ignored.\n    \n        This function always returns an object which can work as a context\n        manager and has methods such as\n    \n        * geturl() - return the URL of the resource retrieved, commonly used to\n          determine if a redirect was followed\n    \n        * info() - return the meta-information of the page, such as headers, in the\n          form of an email.message_from_string() instance (see Quick Reference to\n          HTTP Headers)\n    \n        * getcode() - return the HTTP status code of the response.  Raises URLError\n          on errors.\n    \n        For HTTP and HTTPS URLs, this function returns a http.client.HTTPResponse\n        object slightly modified. In addition to the three new methods above, the\n        msg attribute contains the same information as the reason attribute ---\n        the reason phrase returned by the server --- instead of the response\n        headers as it is specified in the documentation for HTTPResponse.\n    \n        For FTP, file, and data URLs and requests explicitly handled by legacy\n        URLopener and FancyURLopener classes, this function returns a\n        urllib.response.addinfourl object.\n    \n        Note that None may be returned if no handler handles the request (though\n        the default installed global OpenerDirector uses UnknownHandler to ensure\n        this never happens).\n    \n        In addition, if proxy settings are detected (for example, when a *_proxy\n        environment variable like http_proxy is set), ProxyHandler is default\n        installed and makes sure the requests are handled through the proxy.\n    \n        '''\n        global _opener\n        if cafile or capath or cadefault:\n            import warnings\n            warnings.warn(\"cafile, capath and cadefault are deprecated, use a \"\n                          \"custom context instead.\", DeprecationWarning, 2)\n            if context is not None:\n                raise ValueError(\n                    \"You can't pass both context and any of cafile, capath, and \"\n                    \"cadefault\"\n                )\n            if not _have_ssl:\n                raise ValueError('SSL support not available')\n            context = ssl.create_default_context(ssl.Purpose.SERVER_AUTH,\n                                                 cafile=cafile,\n                                                 capath=capath)\n            https_handler = HTTPSHandler(context=context)\n            opener = build_opener(https_handler)\n        elif context:\n            https_handler = HTTPSHandler(context=context)\n            opener = build_opener(https_handler)\n        elif _opener is None:\n            _opener = opener = build_opener()\n        else:\n            opener = _opener\n>       return opener.open(url, data, timeout)\n\n/usr/local/Cellar/python/3.7.5/Frameworks/Python.framework/Versions/3.7/lib/python3.7/urllib/request.py:222: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib.request.OpenerDirector object at 0x10e846890>, fullurl = <urllib.request.Request object at 0x10e846710>\ndata = None, timeout = <object object at 0x10c7353e0>\n\n    def open(self, fullurl, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT):\n        # accept a URL or a Request object\n        if isinstance(fullurl, str):\n            req = Request(fullurl, data)\n        else:\n            req = fullurl\n            if data is not None:\n                req.data = data\n    \n        req.timeout = timeout\n        protocol = req.type\n    \n        # pre-process request\n        meth_name = protocol+\"_request\"\n        for processor in self.process_request.get(protocol, []):\n            meth = getattr(processor, meth_name)\n>           req = meth(req)\n\n/usr/local/Cellar/python/3.7.5/Frameworks/Python.framework/Versions/3.7/lib/python3.7/urllib/request.py:523: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib.request.HTTPHandler object at 0x10e8467d0>, request = <urllib.request.Request object at 0x10e846710>\n\n    def do_request_(self, request):\n        host = request.host\n        if not host:\n            raise URLError('no host given')\n    \n        if request.data is not None:  # POST\n            data = request.data\n            if isinstance(data, str):\n                msg = \"POST data should be bytes, an iterable of bytes, \" \\\n                      \"or a file object. It cannot be of type str.\"\n>               raise TypeError(msg)\nE               TypeError: POST data should be bytes, an iterable of bytes, or a file object. It cannot be of type str.\n\n/usr/local/Cellar/python/3.7.5/Frameworks/Python.framework/Versions/3.7/lib/python3.7/urllib/request.py:1247: TypeError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <test_case.Test_case object at 0x10e846090>\ncase = {'case_expect': '{\"code\": 0}', 'case_id': 'asc-0006', 'case_method': 'POST', 'case_module': 'flask', ...}\n\n    @pytest.mark.parametrize('case', ExcelHandler().get_excel_data)\n    def test_case(self, case):\n        \"\"\"  执行断言 \"\"\"\n        # 发请求\n>       response = RequestHandler(case).send_request()\n\ntest_case.py:22: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <RequestHandler.RequestHandler object at 0x10e846490>\n\n    def send_request(self):\n        \"\"\" 发请求 \"\"\"\n        headers = {'Content-Type': 'application/json'}\n        try:\n            put_request = urllib.request.Request(\n                url=self.case['case_url'],\n                data=self.case['case_params'],\n                headers=headers,\n                method=self.case['case_method'])\n            res = urllib.request.urlopen(put_request) #返回参数\n            response = res.read().decode('utf-8') #请求返回的body\n            print(response)\n        except:\n            logger().error({'response': \"请求发送失败，详细信息： url={}\".format(self.case['case_url'])})\n>           logger().error({res})\nE           UnboundLocalError: local variable 'res' referenced before assignment\n\nRequestHandler.py:49: UnboundLocalError"}, "description": "  执行断言 ", "attachments": [{"name": "log", "source": "d5932479-1ba2-4695-a57b-b9a244010176-attachment.txt", "type": "text/plain"}], "parameters": [{"name": "case", "value": "{'case_id': 'asc-0006', 'case_module': 'flask', 'case_url': 'http://janusapi.info.eleme.test/api/v1/imageCodes', 'isRun': 'RUN', 'case_method': 'POST', 'case_params': '{\"width\":10,\"height\":10}', 'case_expect': '{\"code\": 0}', 'case_result_code': '', 'case_result_message': '', 'code': 0.0, 'message': 'SUCCESS'}"}], "start": 1586944681027, "stop": 1586944681041, "uuid": "6b297ca6-ee1f-4f31-9121-88fbee10515a", "historyId": "99c9325b3cbc090057cd9207f21dc4fb", "testCaseId": "71937dd9396169d89730de47118e43a8", "fullName": "demo.test_case.Test_case#test_case", "labels": [{"name": "parentSuite", "value": "demo"}, {"name": "suite", "value": "test_case"}, {"name": "subSuite", "value": "Test_case"}, {"name": "host", "value": "localhost"}, {"name": "thread", "value": "10912-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython3"}, {"name": "package", "value": "demo.test_case"}]}